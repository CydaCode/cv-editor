# S3 Security Best Practices

## ⚠️ Important: Do NOT Expose S3 Bucket Name in Frontend

### Why?

1. **Security Risk**: Exposing bucket names publicly can help attackers identify your infrastructure
2. **Best Practice**: All file access should go through your backend API
3. **Access Control**: The backend can implement proper authentication and authorization
4. **Signed URLs**: If direct S3 access is needed, use time-limited signed URLs generated by the backend

## Current Architecture

```
Frontend (Browser)
    ↓ HTTP Request
Backend API (/api/download/:id/text)
    ↓ S3 SDK (with credentials)
AWS S3 Bucket
```

### Frontend → Backend → S3

- ✅ Frontend calls backend API
- ✅ Backend has S3 credentials
- ✅ Backend downloads/proxies files from S3
- ✅ Backend returns file to frontend

## Environment Variables

### Backend Only (`backend/.env`)

```env
# ✅ Correct - Backend only
AWS_REGION=us-east-1
S3_BUCKET_NAME=cv-editor-prod
AWS_ACCESS_KEY_ID=your-key
AWS_SECRET_ACCESS_KEY=your-secret
```

### Frontend (`frontend/.env.local`)

```env
# ✅ Correct - Only API URL
NEXT_PUBLIC_API_URL=http://localhost:5000/api

# ❌ WRONG - Never do this
# NEXT_PUBLIC_S3_BUCKET=cv-editor-prod
```

## Alternative: Signed URLs (If Needed)

If you need direct S3 access from the frontend, generate signed URLs in the backend:

### Backend Endpoint

```javascript
// GET /api/cv/:id/signed-url
router.get('/:id/signed-url', async (req, res) => {
  const cv = await CV.findById(req.params.id);
  const signedUrl = await getSignedUrl(cv.filePath); // Expires in 1 hour
  res.json({ signedUrl });
});
```

### Frontend Usage

```javascript
// Frontend calls backend to get signed URL
const response = await axios.get(`${API_URL}/cv/${id}/signed-url`);
window.open(response.data.signedUrl); // Direct S3 access with time limit
```

This way:
- ✅ Bucket name stays in backend
- ✅ URLs expire after a set time
- ✅ Backend can add authentication/authorization
- ✅ No credentials exposed to frontend

## Summary

| Approach | Security | Recommendation |
|----------|----------|----------------|
| Backend API proxy | ✅ High | ✅ **Recommended** - Current implementation |
| Signed URLs (backend-generated) | ✅ Medium-High | ✅ Good for large files |
| Direct S3 access (public bucket) | ❌ Low | ❌ **Never** - Security risk |
| Expose bucket name in frontend | ❌ Low | ❌ **Never** - Unnecessary exposure |

## Current Implementation

The current download routes serve text/HTML content from the database (parsed content), not the original S3 files. If you need to download original PDF/DOCX files from S3, we can add a backend endpoint that:

1. Retrieves the file from S3 using the stored `filePath` (S3 key)
2. Streams it to the client
3. Or generates a signed URL for direct download

Let me know if you'd like to implement this feature!

